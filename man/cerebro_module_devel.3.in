\."#############################################################################
\."$Id: cerebro_module_devel.3.in,v 1.16 2006-07-03 20:40:49 chu11 Exp $
\."#############################################################################
\."  Copyright (C) 2005 The Regents of the University of California.
\."  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
\."  Written by Albert Chu <chu11@llnl.gov>.
\."  UCRL-CODE-155989 All rights reserved.
\."
\."  This file is part of Cerebro, a collection of cluster monitoring tools
\."  and libraries.  For details, see <http://www.llnl.gov/linux/cerebro/>.
\."
\."  Cerebro is free software; you can redistribute it and/or modify it under
\."  the terms of the GNU General Public License as published by the Free
\."  Software Foundation; either version 2 of the License, or (at your option)
\."  any later version.
\."
\."  Cerebro is distributed in the hope that it will be useful, but WITHOUT ANY
\."  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
\."  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
\."  details.
\."
\."  You should have received a copy of the GNU General Public License along
\."  with Cerebro; if not, write to the Free Software Foundation, Inc.,
\."  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
\."#############################################################################
.TH LIBCEREBRO 3 "May 2005" "LLNL" "LIBCEREBRO"
.SH "NAME"
Introduction to writing cerebro modules
.SH "SYNOPSIS"
.B #include <cerebro/cerebro_clusterlist_module.h>
.sp
.B #include <cerebro/cerebro_config.h>
.sp
.B #include <cerebro/cerebro_config_module.h>
.sp
.B #include <cerebro/cerebro_constants.h>
.sp
.B #include <cerebro/cerebro_error.h>
.sp
.BI "void cerebro_err_debug(const char *fmt, ...);"
.br
.SH "DESCRIPTION"
Additional information about the development of cerebro clusterlist
and config modules can be found below.

Module writers should use \fBcerebro_err_debug\fR when debugging
information is output.

.SH "CLUSTERLIST MODULES"
A cerebro clusterlist module of the name 'foobar' can be written by
compiling a shared object library with the filename
cerebro_clusterlist_foobar.so, and installing it in the cerebro
package library directory @CEREBRO_MODULE_DIR@.

The clusterlist module should define a structure of the following
type:

.nf
struct cerebro_clusterlist_module_info {
.in +2
  char *clusterlist_module_name;
  Cerebro_clusterlist_setup setup;
  Cerebro_clusterlist_cleanup cleanup;
  Cerebro_clusterlist_numnodes numnodes;
  Cerebro_clusterlist_get_all_nodes get_all_nodes;
  Cerebro_clusterlist_node_in_cluster node_in_cluster;
  Cerebro_clusterlist_get_nodename get_nodename;
.in -2
};
.fi

The structure should be named 'clusterlist_module_info' and be populated
with the following information.

The field 'clusterlist_module_name' should indicate the name of the
clusterlist module.

The field 'setup' should point to a function of the following type:

typedef int (*Cerebro_clusterlist_setup)(void);

The 'setup' function sets up the clusterlist module with whatever
initialization is necessary.  It returns 0 on success, -1 on error.

The field 'cleanup' should point to a function of the following type:

typedef int (*Cerebro_clusterlist_cleanup)(void);

The 'cleanup' function cleans up the clusterlist module from earlier
initializations.  It returns 0 on success, -1 on error.

The field 'numnodes' should point to a function of the following type:

typedef int (*Cerebro_clusterlist_numnodes)(void);

The 'numnodes' function returns the number of nodes in the
cluster, or -1 on error.

The field 'get_all_nodes' should point to a function of the following type:

typedef int (*Cerebro_clusterlist_get_all_nodes)(char ***nodes);

The 'get_all_nodes' function retrieves a list of nodes in the cluster.
The caller is responsible for freeing the created char ** array of
nodes.  The returned array of strings should be NULL
terminated. Returns the number of cluster nodes retrieved on success,
-1 on error.

The field 'node_in_cluster' should point to a function of the following type:

typedef int (*Cerebro_clusterlist_node_in_cluster)(const char *node);

The 'node_in_cluster' function is passed a nodename.  It returns 1 if
the specified node is in the cluster, 0 if not, and -1 on error.

The field 'get_nodename' should point to a function of the following type:

typedef int (*Cerebro_clusterlist_get_nodename)(const char *node, char *buf, unsigned int buflen);

The 'get_nodename' function is passed a nodename, a buffer, and a
buffer length.  It determines the appropriate nodename to use and
copies it into the buffer.  This function is primarily used to convert
aliased nodenames into the appropriate nodename to use for
calculations.  The majority of clusterlist module writers will
probably copy the nodename directly into the buffer and not do any
calculations.  'get_nodename' returns 0 on success, -1 on error.

All of the above functions must be defined in the module and listed in
the 'clusterlist_module_info' structure.

.SH "CONFIG MODULES"
A cerebro config module of the name 'foobar' can be written by
compiling a shared object library with the filename
cerebro_config_foobar.so, and installing it in the cerebro package
library directory  @CEREBRO_MODULE_DIR@.

The config module should define a structure of the following
type:

.nf
struct cerebro_config_module_info {
.in +2
  char *config_module_name;
  Cerebro_config_setup setup;
  Cerebro_config_cleanup cleanup;
  Cerebro_config_load_default load_default;
.in -2
};
.fi

The structure should be named 'config_module_info' and be populated
with the following information.

The field 'config_module_name' should indicate the name of the
config module.

The field 'setup' should point to a function of the following type:

typedef int (*Cerebro_config_setup)(void);

The 'setup' function sets up the config module with whatever
initialization is necessary.  It returns 0 on success, -1 on error.

The field 'cleanup' should point to a function of the following type:

typedef int (*Cerebro_config_cleanup)(void);

The 'cleanup' function cleans up the config module from earlier
initializations.  It returns 0 on success, -1 on error.

The field 'load_default' should point to a function of the following
type:

typedef int (*Cerebro_config_load_default)(struct cerebro_config *conf);

The 'load_default' function loads an alternate set of configuration
values and stores them within the configuration structure passed in.

All of the above functions must be defined in the module and listed in
the 'config_module_info' structure.

The structure cerebro_config is defined as:

.nf
struct cerebro_config {
.in +2
  char cerebro_hostnames[CEREBRO_CONFIG_HOSTNAMES_MAX][CEREBRO_MAXNODENAMELEN+1];
  int cerebro_hostnames_len;
  int cerebro_hostnames_flag;
  unsigned int cerebro_port;
  int cerebro_port_flag;
  unsigned int cerebro_timeout_len;
  int cerebro_timeout_len_flag;
  int cerebro_flags;
  int cerebro_flags_flag;

  unsigned int cerebrod_heartbeat_frequency_min;
  unsigned int cerebrod_heartbeat_frequency_max;
  int cerebrod_heartbeat_frequency_flag;
  int cerebrod_heartbeat_source_port;
  int cerebrod_heartbeat_source_port_flag;
  char cerebrod_heartbeat_source_network_interface[CEREBRO_MAXNETWORKINTERFACELEN+1];
  int cerebrod_heartbeat_source_network_interface_flag;
  int cerebrod_heartbeat_destination_port;
  int cerebrod_heartbeat_destination_port_flag;
  char cerebrod_heartbeat_destination_ip[CEREBRO_MAXIPADDRLEN+1];
  int cerebrod_heartbeat_destination_ip_flag;
  int cerebrod_heartbeat_ttl;
  int cerebrod_heartbeat_ttl_flag;
  int cerebrod_speak;
  int cerebrod_speak_flag;
  int cerebrod_listen;
  int cerebrod_listen_flag;
  int cerebrod_listen_threads;
  int cerebrod_listen_threads_flag;
  int cerebrod_listen_ports[CEREBRO_MAX_LISTENERS];
  int cerebrod_listen_ports_len;
  int cerebrod_listen_ports_flag;
  char cerebrod_listen_ips[CEREBRO_MAX_LISTENERS][CEREBRO_MAX_IPADDR_LEN+1];
  int cerebrod_listen_ips_len;
  int cerebrod_listen_ips_flag;
  char cerebrod_listen_network_interfaces[CEREBRO_MAX_LISTENERS][CEREBRO_MAX_NETWORK_INTERFACE_LEN+1];
  int cerebrod_listen_network_interfaces_len;
  int cerebrod_listen_network_interfaces_flag;
  int cerebrod_metric_controller;
  int cerebrod_metric_controller_flag;
  int cerebrod_metric_server;
  int cerebrod_metric_server_flag;
  int cerebrod_metric_server_port;
  int cerebrod_metric_server_port_flag;
  int cerebrod_metric_max;
  int cerebrod_metric_max_flag;
  int cerebrod_monitor_max;
  int cerebrod_monitor_max_flag;
.if @MANPAGE_DEBUG@ \{
  int cerebrod_speak_debug;
  int cerebrod_speak_debug_flag;
  int cerebrod_listen_debug;
  int cerebrod_listen_debug_flag;
  int cerebrod_metric_controller_debug;
  int cerebrod_metric_controller_debug_flag;
  int cerebrod_metric_server_debug;
  int cerebrod_metric_server_debug_flag;
\}
.in -2
};
.fi

The 'cerebro_hostnames' field should store an array of default
hostnames for the libcerebro API should attempt to connect to.

The 'cerebro_port' field should store the default port for the
libcerebro API should attempt to connect to.

The 'cerebro_timeout_len' field should store the default timeout
length the libcerebro API should use to evaluate up vs. down nodes.

The 'cerebro_flags' field should store the default flags the
libcerebro API should use.

The 'cerebrod_heartbeat_frequency_min' and
'cerebrod_heartbeat_frequency_max' fields store the minimum and
maximum heartbeat frequencey for
.BR cerebrod(8).

The 'cerebrod_heartbeat_source_port' field stores the heartbeat source
port for
.BR cerebrod(8).

The 'cerebrod_heartbeat_source_network_interface' field stores the heartbeat
network interface for
.BR cerebrod(8)
to send heartbeat packets out of.  The network interface can be
specified as a network interface, ip address, or a subnet using CIDR
notation.

The 'cerebrod_heartbeat_destination_port' field stores the heartbeat
destination port for
.BR cerebrod(8).

The 'cerebrod_heartbeat_destination_ip' field stores the heartbeat
destination ip of heartbeat packets sent from
.BR cerebrod(8).
The destination IP address may be a single case or multicast IPv4
address.

The 'cerebrod_heartbeat_ttl' field stores the heartbeat time to live
for heartbeat packets multicast from
.BR cerebrod(8).

The 'cerebrod_speak' field is a boolean that turns on the 
.BR cerebrod(8)
speaker to send out heartbeat packets.

The 'cerebrod_listen' field is a boolean that turns on the
.BR cerebrod(8)
listener to receive heartbeat packets.

The 'cerebrod_listen_threads' field stores the number of listener
threads that should be created in
.BR cerebrod(8).

The 'cerebrod_listen_ports' field stores the ports
.BR cerebrod(8)
should listen for heratbeat packets on.

The 'cerebrod_listen_ips' field stores the IP addresses
.BR cerebrod(8)
should listen for heratbeat packets on.

The 'cerebrod_listen_network_interfaces' field stores the network
interfaces
.BR cerebrod(8)
should listen for heratbeat packets on.  The network interface can be
specified as a network interface, ip address, or a subnet using CIDR
notation.

The 'cerebrod_metric_controller' field is a boolean that turns on the
.BR cerebrod(8)
metric controller to receive metric control requests.

The 'cerebrod_metric_server' field is a boolean that turns on the
.BR cerebrod(8)
metric server to receive metric data requests.

The 'cerebrod_metric_server_port' field stores the metric server
port for 
.BR cerebrod(8).

The 'cerebrod_metric_max' field stores the maximum number of 
additional metrics the 
.BR cerebrod(8)
speaker is allowed to distribute.

The 'cerebrod_monitor_max' field stores the maximum number of 
metric monitors the 
.BR cerebrod(8)
listener is allowed to load.

.if @MANPAGE_DEBUG@ \{

The 'cerebrod_speak_debug' field is a boolean that turns on speaker
debugging for 
.BR cerebrod.

The 'cerebrod_listen_debug' field is a boolean that turns on listener
debugging for
.BR cerebrod.

The 'cerebrod_metric_controller_debug' field is a boolean that turns on
metric controller debugging for
.BR cerebrod.

The 'cerebrod_metric_server_debug' field is a boolean that turns on
metric server debugging for
.BR cerebrod.

\}

Any parameter that is set in the configuration structure must have its
respective flag set.  The 'hostnames' field must also have the
'hostnames_len' field appropriately set to the number of hostnames
loaded.

.SH "METRIC MODULES"
A cerebro metric module of the name 'foobar' can be written by
compiling a shared object library with the filename
cerebro_metric_foobar.so, and installing it in the cerebro
package library directory @CEREBRO_MODULE_DIR@.

The metric module should define a structure of the following
type:

.nf
struct cerebro_metric_module_info {
.in +2
  Cerebro_metric_setup setup;
  Cerebro_metric_cleanup cleanup;
  Cerebro_metric_get_metric_name get_metric_name;
  Cerebro_metric_get_metric_period get_metric_period;
  Cerebro_metric_get_metric_value get_metric_value;
  Cerebro_metric_destroy_metric_value destroy_metric_value;
  Cerebro_metric_get_metric_thread get_metric_thread;
  Cerebro_metric_send_heartbeat_function_pointer send_heartbeat_function_pointer;
.in -2
};
.fi

The structure should be named 'metric_module_info' and be populated
with the following information.

The field 'metric_module_name' should indicate the name of the
metric module.

The field 'setup' should point to a function of the following type:

typedef int (*Cerebro_metric_setup)(void);

The 'setup' function sets up the metric module with whatever
initialization is necessary.  It returns 0 on success, -1 on error.

The field 'cleanup' should point to a function of the following type:

typedef int (*Cerebro_metric_cleanup)(void);

The 'cleanup' function cleans up the metric module from earlier
initializations.  It returns 0 on success, -1 on error.

The field 'get_metric_name' should point to a function of the following type:

typedef char *(*Cerebro_metric_get_metric_name)(void);

The 'get_metric_name' function returns the name of the metric to be
monitored, or NULL on error.

The field 'get_metric_period' should point to a function of the following type:

typedef int (*Cerebro_metric_get_metric_period)(int *period);

The 'get_metric_period' function retrieves the period in seconds that
the metric value should be read and propogated.  If the period is 0,
the metric will be read and propogated with every cerebro
heartbeat. If the period is < 0, the metric will be propogated only
when instructed to. Note that the period is not precise, and is only
an approximation.  Data is only propogated in cerebro heartbeats,
therefore the period time granularity will be related to the cerebro
heartbeat period.  It returns 0 on success, -1 on error.

The field 'get_metric_value' should point to a function of the following type:

typedef int (*Cerebro_metric_get_metric_value)(unsigned int *metric_value_type, unsigned int *metric_value_len, void **metric_value);

The 'get_metric_value' function retrieves the value of the metric as
well as the type and length.  If it is necessary, it is the
responsibility of 'get_metric_value' to allocate an appropriate amount
of memory for the returned value.  Returns the 0 on success, -1 on
error.

The field 'destroy_metric_value' should point to a function of the following type:

typedef int (*Cerebro_metric_destroy_metric_value)(void *metric_value);

The 'destroy_metric_value' function is passed the metric value pointer
received from 'get_metric_value'.  If necessary,
'destroy_metric_value' should free allocated memory.  Returns 0 on
success, -1 on error.

The field 'get_metric_thread' should point to a function of the following type:

typedef Cerebro_metric_thread_pointer (*Cerebro_metric_get_metric_thread)(void);

The 'get_metric_thread' function returns a pointer of type:

typedef void *(*Cerebro_metric_thread_pointer)(void *arg);

which will be executed as a detached thread.  

The function will be passed a pointer to a function of type:

typedef int (*Cerebro_metric_updated)(char *metric_name);

This thread can perform any metric monitoring duties it pleases and
optionally call the 'Cerebro_metric_updated' function when a metric
value is updated.

Typically the thread is used to watch or monitor for some event and
locally update data so that cerebrod will propogate the newly received
data from a 'get_metric_value' call.
 
If the user wishes to use mutexes within the metric thread to protect
against concurrent access, the user is responsible for not putting the
locks in situations that can lead to a deadlock.  The
'Cerebro_metric_updated' function call may require locks to function
appropriately within the cerebrod daemon.

If no detached thread is required to be executed by this module, NULL
should be returned.

If the 
.B cerebrod
daemon was built without threads, the 'get_metric_thread' function will
never be called.

The field 'send_heartbeat_function_pointer' should point to a function of the following type:

typedef int (*Cerebro_metric_send_heartbeat_function_pointer)(Cerebro_metric_send_heartbeat function_pointer););

The 'send_heartbeat_function_pointer' receives a pointer of the type:

typedef int (*Cerebro_metric_send_heartbeat)(struct cerebrod_heartbeat *hb);

The pointer will allow the metric module to send a heartbeat message.

All of the above functions must be defined in the module and listed in
the 'metric_module_info' structure.

.SH "MONITOR MODULES"
A cerebro monitor module of the name 'foobar' can be written by
compiling a shared object library with the filename
cerebro_monitor_foobar.so, and installing it in the cerebro
package library directory @CEREBRO_MODULE_DIR@.

The monitor module should define a structure of the following
type:

.nf
struct cerebro_monitor_module_info {
.in +2
  char *monitor_module_name;
  Cerebro_monitor_setup setup;
  Cerebro_monitor_cleanup cleanup;
  Cerebro_monitor_metric_name metric_name;
  Cerebro_monitor_metric_update metric_update;
.in -2
};
.fi

The structure should be named 'monitor_module_info' and be populated
with the following information.

The field 'monitor_module_name' should indicate the name of the
monitor module.

The field 'setup' should point to a function of the following type:

typedef int (*Cerebro_monitor_setup)(void);

The 'setup' function sets up the monitor module with whatever
initialization is necessary.  It returns 0 on success, -1 on error.

The field 'cleanup' should point to a function of the following type:

typedef int (*Cerebro_monitor_cleanup)(void);

The 'cleanup' function cleans up the monitor module from earlier
initializations.  It returns 0 on success, -1 on error.

The field 'metric_names' should point to a function of the following type:

typedef char *(*Cerebro_monitor_metric_names)(void);

The 'metric_names' function returns the name(s) of the metric(s) the module
wishes to monitor, or NULL on error.  Multiple metrics are comma separated.

The field 'metric_update' should point to a function of the following type:

typedef int (*Cerebro_monitor_metric_update)(const char *nodename, unsigned int metric_value_type, unsigned int metric_value_len, void *metric_value);

The 'metric_update' function is called whenever the metric is received from a node.
The nodename the metric was received from, metric value type, metric value length, and metric value are passed in as arguments.  
Returns the 0 on success, -1 on error.

All of the above functions must be defined in the module and listed in
the 'monitor_module_info' structure.


.SH "SEE ALSO"
libcerebro(3), cerebro_module(3), cerebro.conf(5), cerebrod(8)
